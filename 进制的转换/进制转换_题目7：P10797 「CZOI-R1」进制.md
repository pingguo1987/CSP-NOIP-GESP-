## 题目7：P10797 「CZOI-R1」进制

[P10797 「CZOI-R1」进制](https://www.luogu.com.cn/problem/P10797)

**同类题目**



### 前置知识

- 无

**题目描述**

你有一个数 $x$，你需要对它进行 $n$ 次操作。

每次操作，你可以选择 $y$ 进制下的数 $x$ 的某一个有效位上数值增加 $1$。  
第一个非零数位及其后面的数位是有效位。

注意：
* **对于每次操作**，你可以任意取 $y\in[2,+\infty)$；
* 你需保证增加操作不会使 $y$ 进制下的数 $x$ 产生进位。

现在你需要求 $n$ 次操作后这个数最大是多少。

答案以十进制输出，并对 $10^9+7$ 取模。你需要输出的是这个数的最大值对 $10^9+7$ 取模的结果，而并非对 $10^9+7$ 取模后的最大值。

**输入格式**

**本题有多组测试数据。**

第一行一个整数 $T$，表示数据组数。

接下来 $T$ 行，每行两个整数 $x,n$，分别表示初始数字、操作次数。

**输出格式**

对于每组测试数据，输出一行一个整数，表示 $x$ 进行 $n$ 次操作后的最大值。

**样例输入 #1**

```
1
2 1
```

**样例输出 #1**

```
3
```

**提示**

**【样例解释】**

很明显，$2$ 在二进制时为 $10$，在三或更高进制时为 $2$。

二进制时，在第一位 $+1$ 会导致二进制产生进位，只能在第二位 $+1$，此时得到的结果为 $11$，转换为十进制为 $3$。

在三或更高进制时，只能往末位 $+1$，三进制下会产生进位，舍去。四或更高进制时得到结果均为 $3$，转化为十进制的结果也是 $3$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask #1（$20\text{ pts}$）：$x\le 2$。
- Subtask #2（$20\text{ pts}$）：$n=1$。
- Subtask #3（$60\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le x,n\le10^9$，$1\le T\le10^6$。

**思路分析**

分三种情况进行讨论

- 当x = 1 时，能够获得的最大值是什么
- 当x = 2 时，能够获得的最大值是什么
- 当x >= 3 时，能够获得的最大值是什么



图解 x = 1 时，对 y 进制下的 x 的某一有效位 + 1 并且不能产生进位的情况下，能获得的最大值为2



<img src ="https://cdn.jsdelivr.net/gh/pingguo1987/CSP-NOIP-GESP-/image/pic/进制的转换/进制转换_题目7：P10797 「CZOI-R1」进制/x=1ychange.png" />



图解 x = 2 时，对 y 进制下的 x 的某一有效位 + 1 并且不能产生进位的情况下，能获得的最大值为 3



<img src ="https://cdn.jsdelivr.net/gh/pingguo1987/CSP-NOIP-GESP-/image/pic/进制的转换/进制转换_题目7：P10797 「CZOI-R1」进制/x=2ychange.png" />



图解 x >= 3 时，对 y 进制下的 x 的某一有效位 + 1 并且不能产生进位的情况下，能获得的最大值



<img src ="https://cdn.jsdelivr.net/gh/pingguo1987/CSP-NOIP-GESP-/image/pic/进制的转换/进制转换_题目7：P10797 「CZOI-R1」进制/x=3ychange.png" />



**程序代码**

```c++
//https://www.luogu.com.cn/problem/P10797
//P10797 「CZOI-R1」进制
#include<iostream>
using namespace std;

const int MOD = 1e9 + 7;

long long cal(int x,int n)
{
    long long res = x;
    long long base = 2;
    // 当n>0,n 转成二进制后的形式为100000001001 这种
    // 以n=8为例，x*2^8，二进制位1000
    // n >>= 1,会执行3次，base 的值变成256，正好和2^8相等
    while(n)
    {
        // 遇到1的时，n & 1 为真
        if(n & 1)
        {
            res = (res*base)%MOD;          
        }
        
        n >>= 1;
        base = (base*base)%MOD;
    }
    
    return res;
}


int main()
{
    int t;
    cin>>t;
    for(int i=1;i<=t;i++)
    {
        int x,n;
        cin>>x>>n;

        // 如果x == 1，变成任何进制，最大值只能变成2
        if(x == 1)
        {   
            x = 2;
            n --;
            // 如果此时n == 0了，那么就结束了
            if(n == 0)
            {
                cout<<"2"<<endl;
                continue;
            }
            
        }
        // 如果x == 2,变成任何进制，最大值只能变成3
        if(x == 2)
        {
            x = 3;
            n--;
        }
        // 如果x >= 3,变成x 进制后，是10，这个时候再在最高位 +1 ,则变化后的值是最大的
        // 例如，x = 4, 变成4进制后是 10, 高位+1 变成20，2*4^1 + 0 = 8
        // 如果n 不为0，则在此基础上继续  8-->8进制--->10--->20--->2*8^1 = 2*2*4 = 16
        // 最终归纳总结为：2^n*x
        if(x >= 3)
        {
            long long res = cal(x,n);
            cout<<res<<endl;
        }  
    }
    return 0;
}
```

**题目感悟**

本题是一个推导题目，需要进行总结推导才能发现最终的变化规律，在进行计算结果时，需要用到位移，如果用循环时间会爆炸。

更多相关知识：https://github.com/pingguo1987/CSP-NOIP-GESP-

---

欢迎关注我的公众号**wangsir 聊信息学**，原创技术文章第一时间推送。

<center>
    <img src="https://cdn.jsdelivr.net/gh/pingguo1987/CSP-NOIP-GESP-/image/pic/公众号-扫码版.png">
</center>
