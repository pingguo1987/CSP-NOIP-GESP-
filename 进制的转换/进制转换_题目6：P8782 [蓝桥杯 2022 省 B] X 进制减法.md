## 题目6：P8782 [蓝桥杯 2022 省 B] X 进制减法

[P8782 [蓝桥杯 2022 省 B] X 进制减法](https://www.luogu.com.cn/problem/P8782)

本题是多进制的减法

**同类题目**



### 前置知识

- 无



**题目描述**

进制规定了数字在数位上逢几进一。

$X$ 进制是一种很神奇的进制，因为其每一数位的进制并不固定！例如说某种 $X$ 进制数，最低数位为二进制，第二数位为十进制，第三数位为八进制，则 $X$ 进制数 `321` 转换为十进制数为 `65`。

现在有两个 $X$ 进制表示的整数 $A$ 和 $B$，但是其具体每一数位的进制还不确定，只知道 $A$ 和 $B$ 是同一进制规则，且每一数位最高为 $N$ 进制，最低为二进制。请你算出 $A-B$ 的结果最小可能是多少。

请注意，你需要保证 $A$ 和 $B$ 在 $X$ 进制下都是合法的, 即每一数位上的数字要小于其进制。

**输入格式**

第一行一个正整数 $N$，含义如题面所述。

第二行一个正整数 $M_{a}$，表示 $X$ 进制数 $A$ 的位数。

第三行 $M_{a}$ 个用空格分开的整数，表示 $X$ 进制数 $A$ 按从高位到低位顺序各个数位上的数字在十进制下的表示。

第四行一个正整数 $M_{b}$，表示 $X$ 进制数 $B$ 的位数。

第五行 $M_{b}$ 个用空格分开的整数，表示 $X$ 进制数 $B$ 按从高位到低位顺序各个数位上的数字在十进制下的表示。

请注意，输入中的所有数字都是十进制的。

**输出格式**

输出一行一个整数，表示 $X$ 进制数 $A-B$ 的结果的最小可能值转换为十进制后再模 $1000000007$（即 $10^9+7$）的结果。

**样例输入 #1**

```
11
3
10 4 0
3
1 2 0
```

**样例输出 #1**

```
94
```

**提示**

**【样例说明】**

当进制为：最低位 $2$ 进制, 第二数位 $5$ 进制, 第三数位 $11$ 进制时, 减法得到的差最小。此时 $A$ 在十进制下是 $108$，$B$ 在十进制下是 $14$，差值是 $94$。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，$N \leq 10,M_{a}, M_{b} \leq 8$.

对于 $100 \%$ 的数据，$2 \leq N \leq 1000,1 \leq M_{a}, M_{b} \leq 10^5,A \geq B$。

蓝桥杯 2022 省赛 B 组 E 题。

**思路分析**

这个题目有3个关键点

- 一个数有多种进制，到底怎么算
- 怎么保证$A-B$ 的结果是最小值
- 取模在哪个地方取

**一个数有多种进制，到底怎么算**

比如题目中的`1 2 0` 和 ` 10  4  0`，最低位 $2$ 进制, 第二数位 $5$ 进制, 第三数位 $11$ 进制时。此时 $A$ 在十进制下是 $108$，$B$ 在十进制下是 $14$。



<img src="https://cdn.jsdelivr.net/gh/pingguo1987/CSP-NOIP-GESP-/image/pic/进制转换_题目6：P8782 [蓝桥杯 2022 省 B] X 进制减法/多进制计算.png" />



**怎么保证$A-B$ 的结果是最小值**

对于每一位，$a_{i}$ 和 $b_{i}$ ,显然这一位的进制$x$ 必须满足 $x>max⁡(a_{i},b_{i})$。 因为要使得差尽可能小，所以每一位进制就是 $max⁡(a_{i},b_{i})+1$ ，这里是贪心思想。

**取模在哪个地方取**

**加法：**每一步加法都取模，加的时候如果不确定是否超范围可以用`long long`接住  `((long long)(a+b))%m `

**乘法：**每一步乘法都取模，乘的时候如果不确定是否超范围可以用`long long`接住` ((long)(a*b))%m`

**减法：**减法的时候防止有负数，需要先加上m。  ` (a%m - b%m + m)%m`



**程序代码**

```c++
//https://www.luogu.com.cn/problem/P8782
//P8782 [蓝桥杯 2022 省 B] X 进制减法

#include<iostream>
#include<cmath>
using namespace std;


const int MOD = 1e9+7;
//const int MX = 100; 
const int MX = 100010; 

// 存储数字
int a[MX];
int b[MX];

// 每一位的最小进制
int base[MX]; 

// 每一位的位权，即这一位的值*d[i] 可以得到这一位代表的数字值
// 例如：10进制的 123, 百位是100，十位是10，个位是1
// 位权可能很大需要long long
long long power[MX];

signed main()
{
	int n; //输入部分 
	cin>>n;
	int ma,mb;
	cin>>ma;
	for(int i=ma;i>=1;i--)
		cin>>a[i];

	cin>>mb;
	for(int i=mb;i>=1;i--)
		cin>>b[i];
	
    // 获取每一位的最大值+1，作为此位的最小进制
	for(int i=max(ma,mb);i>=1;i--) 
		base[i] = max(a[i],b[i]) + 1;
    
    //判断该位的进制是否比2小，如果小则赋值为2
	for(int i=max(ma,mb);i>=1;i--) 
		base[i] = base[i] > 2 ? base[i] : 2;
	
    // 第一位的位权为1
	power[1]=1;  
	for(int i=2;i<=max(ma,mb);i++)
		power[i] = (power[i-1] * base[i-1]) % MOD;
		
	long long suma=0,sumb=0; 
	for(int i=ma;i>=1;i--)
    {
        suma += (a[i] * power[i])%MOD;
        suma %= MOD;
    }

	for(int i=mb;i>=1;i--)
    {
        sumb += (b[i] * power[i])%MOD;
        sumb %= MOD;
    }
	
    // 减法的时候取模，需要在减法中和减法外同时取
	cout<<(suma - sumb + MOD) % MOD; 
	return 0;
}
```



**题目感悟**

这个题目最大的收获在于学会了

- 一个数有多种进制，到底怎么算
- 怎么保证$A-B$ 的结果是最小值
- 加减乘的取模在哪个地方取

---

欢迎关注我的公众号**wangsir 聊信息学**，原创技术文章第一时间推送。

<center>
    <img src="https://cdn.jsdelivr.net/gh/pingguo1987/CSP-NOIP-GESP-/image/pic/公众号-扫码版.png">
</center>
